name: Sync Upstream and Rebase

on:
  schedule:
    # æ¯å¤© UTC æ—¶é—´ 0 ç‚¹æ£€æŸ¥ä¸€æ¬¡ (åŒ—äº¬æ—¶é—´æ—©ä¸Š 8 ç‚¹)
    - cron: '0 0 * * *'
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘

# è¦ä¿ç•™çš„ feature åˆ†æ”¯ (æŒ‰ squash merge é¡ºåº)
env:
  FEATURE_BRANCHES: |
    feat/thinking-aware-model-mapping
    feat/session-affinity
    feat/web-search-claude
    feat/ci-sync-upstream

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}

      - name: Setup Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add upstream remote
        run: |
          git remote add upstream https://github.com/router-for-me/CLIProxyAPI.git || true
          git fetch upstream --tags --force
          git fetch origin --tags --force

      - name: Check if sync needed
        id: check
        run: |
          UPSTREAM_HEAD=$(git rev-parse upstream/main)

          # æ£€æŸ¥ä¸Šæ¸¸ HEAD æ˜¯å¦å·²ç»åœ¨æœ¬åœ°åŽ†å²ä¸­
          if git merge-base --is-ancestor "$UPSTREAM_HEAD" HEAD; then
            echo "Already up to date"
            echo "need_sync=false" >> $GITHUB_OUTPUT
          else
            echo "Need to sync"
            echo "need_sync=true" >> $GITHUB_OUTPUT
          fi

      - name: Rebase feature branches and rebuild main
        if: steps.check.outputs.need_sync == 'true'
        run: |
          echo "=== Rebasing feature branches onto upstream/main ==="

          # è¯»å– feature åˆ†æ”¯åˆ—è¡¨
          BRANCHES=$(echo "$FEATURE_BRANCHES" | tr '\n' ' ' | xargs)

          # å…ˆ rebase æ¯ä¸ª feature åˆ†æ”¯åˆ° upstream/main
          for branch in $BRANCHES; do
            echo "--- Processing $branch ---"

            # æ£€æŸ¥åˆ†æ”¯æ˜¯å¦å­˜åœ¨
            if ! git rev-parse --verify "origin/$branch" >/dev/null 2>&1; then
              echo "Branch $branch not found, skipping"
              continue
            fi

            # checkout åˆ†æ”¯
            git checkout -B "$branch" "origin/$branch"

            # èŽ·å–è¯¥åˆ†æ”¯ç›¸å¯¹äºŽ upstream/main çš„ commit æ•°é‡
            COMMIT_COUNT=$(git rev-list --count upstream/main..HEAD)
            echo "Branch $branch has $COMMIT_COUNT commits ahead of upstream/main"

            # Rebase åˆ° upstream/main
            if ! git rebase upstream/main; then
              echo "Rebase failed for $branch, trying to resolve..."
              git rebase --abort
              echo "ERROR: Could not rebase $branch"
              exit 1
            fi

            # Push rebased branch
            git push origin "$branch" --force-with-lease
            echo "Pushed rebased $branch"
          done

          echo "=== Rebuilding main branch ==="

          # ä»Ž upstream/main å¼€å§‹é‡å»º main
          git checkout -B main upstream/main

          # ä¾æ¬¡ squash merge æ¯ä¸ª feature åˆ†æ”¯
          for branch in $BRANCHES; do
            echo "--- Squash merging $branch ---"

            # æ£€æŸ¥åˆ†æ”¯æ˜¯å¦å­˜åœ¨
            if ! git rev-parse --verify "$branch" >/dev/null 2>&1; then
              echo "Branch $branch not found, skipping"
              continue
            fi

            # èŽ·å–è¯¥åˆ†æ”¯çš„ç¬¬ä¸€ä¸ª commit message ä½œä¸º squash commit message
            COMMIT_MSG=$(git log "$branch" --not upstream/main --format="%s" | tail -1)

            if [ -z "$COMMIT_MSG" ]; then
              echo "No commits to merge from $branch, skipping"
              continue
            fi

            # Squash merge
            git merge "$branch" --squash
            git commit -m "$COMMIT_MSG"

            echo "Squash merged $branch with message: $COMMIT_MSG"
          done

          echo "=== Main branch rebuilt ==="
          git log --oneline -10

      - name: Force push main
        if: steps.check.outputs.need_sync == 'true'
        run: |
          git push origin main --force-with-lease
          echo "Pushed to origin/main"

      - name: Check for new upstream tags
        id: tags
        run: |
          # èŽ·å–ä¸Šæ¸¸æœ€æ–°çš„ tag
          LATEST_UPSTREAM_TAG=$(git describe --tags --abbrev=0 upstream/main 2>/dev/null || echo "")
          echo "Latest upstream tag: $LATEST_UPSTREAM_TAG"

          if [ -z "$LATEST_UPSTREAM_TAG" ]; then
            echo "No tags found"
            echo "new_tag=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # æž„é€ æˆ‘ä»¬çš„ tag åç§°
          OUR_TAG="${LATEST_UPSTREAM_TAG}-antiWebsearch"

          # æ£€æŸ¥è¿™ä¸ª tag æ˜¯å¦å·²ç»åœ¨ origin å­˜åœ¨
          if git ls-remote --tags origin | grep -q "refs/tags/${OUR_TAG}$"; then
            echo "Tag $OUR_TAG already exists in origin"
            echo "new_tag=" >> $GITHUB_OUTPUT
          else
            echo "New tag to create: $OUR_TAG"
            echo "new_tag=$LATEST_UPSTREAM_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Create rebased tag
        if: steps.tags.outputs.new_tag != ''
        id: create_tag
        run: |
          UPSTREAM_TAG="${{ steps.tags.outputs.new_tag }}"
          # æ·»åŠ è‡ªå®šä¹‰åŽç¼€
          NEW_TAG="${UPSTREAM_TAG}-antiWebsearch"
          echo "Creating tag $NEW_TAG on rebased main (based on upstream $UPSTREAM_TAG)"

          # åœ¨å½“å‰ HEAD (åŒ…å«ä½ çš„ commit) ä¸Šåˆ›å»º tag
          git tag -f "$NEW_TAG"
          git push origin "$NEW_TAG" --force

          echo "Tag $NEW_TAG pushed to origin"
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "upstream_tag=$UPSTREAM_TAG" >> $GITHUB_OUTPUT

      - name: Find previous custom tag
        if: steps.tags.outputs.new_tag != ''
        id: prev_tag
        run: |
          # æ‰¾åˆ°æˆ‘ä»¬ä¹‹å‰çš„ antiWebsearch tag
          PREV_TAG=$(git tag -l '*-antiWebsearch' --sort=-version:refname | grep -v "${{ steps.create_tag.outputs.new_tag }}" | head -1)
          echo "Previous custom tag: $PREV_TAG"

          if [ -n "$PREV_TAG" ]; then
            # æå–ä¸Šæ¸¸ç‰ˆæœ¬å·
            PREV_UPSTREAM_TAG=$(echo "$PREV_TAG" | sed 's/-antiWebsearch$//')
            echo "prev_tag=$PREV_TAG" >> $GITHUB_OUTPUT
            echo "prev_upstream_tag=$PREV_UPSTREAM_TAG" >> $GITHUB_OUTPUT
          else
            echo "prev_tag=" >> $GITHUB_OUTPUT
            echo "prev_upstream_tag=" >> $GITHUB_OUTPUT
          fi

      - name: Generate Release Notes
        if: steps.tags.outputs.new_tag != ''
        id: release_notes
        run: |
          NEW_TAG="${{ steps.create_tag.outputs.new_tag }}"
          UPSTREAM_TAG="${{ steps.create_tag.outputs.upstream_tag }}"
          PREV_UPSTREAM_TAG="${{ steps.prev_tag.outputs.prev_upstream_tag }}"

          # ç”Ÿæˆ release notes
          cat > release_notes.md << 'HEADER'
          ## ðŸš€ Custom Features (antiWebsearch)

          This release is based on upstream `UPSTREAM_TAG_PLACEHOLDER` with the following custom modifications:

          HEADER

          sed -i "s/UPSTREAM_TAG_PLACEHOLDER/$UPSTREAM_TAG/" release_notes.md

          # æ·»åŠ è‡ªå®šä¹‰ commit åˆ—è¡¨
          cat >> release_notes.md << 'CUSTOM'
          ### Custom Feature Branches
          - **feat/thinking-aware-model-mapping**: add thinking-aware model mapping for Amp CLI requests
          - **feat/session-affinity**: add session affinity with metadata.user_id priority for Claude Code clients
          - **feat/web-search-claude**: add web_search support for Claude via Gemini googleSearch
          - **feat/ci-sync-upstream**: add workflow to auto sync upstream and rebase custom commits

          ---

          CUSTOM

          # æ·»åŠ ä¸Šæ¸¸æ›´æ–°
          if [ -n "$PREV_UPSTREAM_TAG" ]; then
            echo "## ðŸ“¦ Upstream Changes (since $PREV_UPSTREAM_TAG)" >> release_notes.md
            echo "" >> release_notes.md
            echo "Changes from upstream \`$PREV_UPSTREAM_TAG\` â†’ \`$UPSTREAM_TAG\`:" >> release_notes.md
            echo "" >> release_notes.md

            # èŽ·å–ä¸Šæ¸¸ commit åˆ—è¡¨
            git log --oneline "${PREV_UPSTREAM_TAG}..${UPSTREAM_TAG}" --pretty=format:"- %s" 2>/dev/null >> release_notes.md || echo "- Unable to fetch upstream commits" >> release_notes.md

            echo "" >> release_notes.md
            echo "" >> release_notes.md
            echo "ðŸ“‹ [View full upstream changelog](https://github.com/router-for-me/CLIProxyAPI/compare/${PREV_UPSTREAM_TAG}...${UPSTREAM_TAG})" >> release_notes.md
          else
            echo "## ðŸ“¦ Upstream Changes" >> release_notes.md
            echo "" >> release_notes.md
            echo "Based on upstream [\`$UPSTREAM_TAG\`](https://github.com/router-for-me/CLIProxyAPI/releases/tag/$UPSTREAM_TAG)" >> release_notes.md
          fi

          cat release_notes.md

      - name: Create GitHub Release
        if: steps.tags.outputs.new_tag != ''
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          NEW_TAG="${{ steps.create_tag.outputs.new_tag }}"
          REPO="${{ github.repository }}"

          # åˆ é™¤å·²å­˜åœ¨çš„ releaseï¼ˆå¦‚æžœæœ‰ï¼‰
          gh release delete "$NEW_TAG" --repo "$REPO" --yes 2>/dev/null || true

          # åˆ›å»ºæ–°çš„ release
          gh release create "$NEW_TAG" \
            --repo "$REPO" \
            --title "$NEW_TAG" \
            --notes-file release_notes.md \
            --latest
